import mido
import sys
from collections import defaultdict
from pathlib import Path

def analyze_midi_file(filename):
    """Generic MIDI file analyzer for any generated composition"""
    
    # Check if file exists, if not try the output folder
    file_path = Path(filename)
    if not file_path.exists():
        output_path = Path('output') / file_path.name
        if output_path.exists():
            file_path = output_path
        else:
            print(f"❌ File not found: {filename}")
            print(f"❌ Also checked: {output_path}")
            return
    
    try:
        mid = mido.MidiFile(str(file_path))
    except Exception as e:
        print(f"❌ Error loading {file_path}: {e}")
        return
    
    print(f"🎼 MIDI FILE ANALYSIS: {file_path}")
    print("=" * 50)
    
    # Basic file info
    print(f"📁 File: {file_path}")
    print(f"🎵 Tracks: {len(mid.tracks)}")
    print(f"⏱️  Ticks per beat: {mid.ticks_per_beat}")
    
    # Analyze each track
    for track_num, track in enumerate(mid.tracks):
        print(f"\n🎵 TRACK {track_num + 1}")
        print("-" * 20)
        
        # Track metadata
        track_name = "Untitled"
        tempo_bpm = None
        time_sig = None
        
        # Parse track for metadata and events
        notes_by_channel = defaultdict(list)
        event_counts = defaultdict(int)
        current_time = 0
        
        for msg in track:
            current_time += msg.time
            
            if msg.type == 'track_name':
                track_name = msg.name
            elif msg.type == 'set_tempo':
                tempo_bpm = mido.tempo2bpm(msg.tempo)
            elif msg.type == 'time_signature':
                time_sig = f"{msg.numerator}/{msg.denominator}"
            elif msg.type in ['note_on', 'note_off']:
                event_counts[f"{msg.type}_ch{msg.channel}"] += 1
                if msg.type == 'note_on' and msg.velocity > 0:
                    notes_by_channel[msg.channel].append(msg.note)
        
        print(f"📋 Track Name: {track_name}")
        if tempo_bpm:
            print(f"🎼 Tempo: {tempo_bpm:.1f} BPM")
        if time_sig:
            print(f"🎵 Time Signature: {time_sig}")
        
        # Analyze channels
        for channel in sorted(notes_by_channel.keys()):
            notes = notes_by_channel[channel]
            if notes:
                min_note = min(notes)
                max_note = max(notes)
                channel_name = "Right Hand" if channel == 0 else "Left Hand" if channel == 1 else f"Channel {channel}"
                
                print(f"\n   {channel_name} (Channel {channel}):")
                print(f"     🎼 Range: {note_to_name(min_note)} to {note_to_name(max_note)}")
                print(f"     📊 Notes: {len(notes)}")
                
                # Check piano range appropriateness
                if channel == 0:  # Right hand
                    if min_note >= 48 and max_note <= 84:
                        print(f"     ✅ Good treble range")
                    else:
                        print(f"     ⚠️  Range could be optimized")
                elif channel == 1:  # Left hand
                    if min_note >= 36 and max_note <= 72:
                        print(f"     ✅ Good bass range")
                    elif min_note < 28:
                        print(f"     ❌ Too low for piano")
                    else:
                        print(f"     ⚠️  Range could be optimized")
        
        # Event summary
        if event_counts:
            print(f"\n   📈 Events:")
            for event_type, count in sorted(event_counts.items()):
                print(f"     {event_type}: {count}")
        
        # Calculate length
        total_length_beats = current_time / mid.ticks_per_beat
        total_measures = total_length_beats / 4
        print(f"\n   ⏱️  Length: {total_measures:.1f} measures ({total_length_beats:.1f} beats)")

def note_to_name(note_num):
    """Convert MIDI note number to note name"""
    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
    octave = note_num // 12 - 1
    note_name = notes[note_num % 12]
    return f"{note_name}{octave}"

if __name__ == "__main__":
    if len(sys.argv) > 1:
        for filename in sys.argv[1:]:
            analyze_midi_file(filename)
            if len(sys.argv) > 2:
                print("\n" + "="*60 + "\n")
    else:
        print("Usage: python midi_analyzer.py <midi_file1.mid> [midi_file2.mid] ...")
        print("Analyzes MIDI files generated by the configurable system")
